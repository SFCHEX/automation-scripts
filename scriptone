
import openpyxl
from openpyxl.utils.dataframe import dataframe_to_rows
import pandas as pd
import argparse
import re
from datetime import datetime, timedelta
from fuzzywuzzy import fuzz
import os

custom_rules = {
    r"(HW|SW)": {
        "Reason Category": "BSS",
        "Reason Sub-Category": "BSS_HW"
    },

    r"SW": {
        "Reason Category": "BSS",
        "Reason Sub-Category": "BSS_SW"
    },

    r"HT": {
        "Reason Category": "High_temp",
        "Reason Sub-Category": "High_temp"
    },


    r"TX": {
        "Reason Category": "TX",
        "Reason Sub-Category": ""
    }


#    r"": {
#        "Reason Category": "",
#        "Reason Sub-Category": ""
#    }
#


    # Add more rules here...
}



desired_header_order = ["Date", "Region", "BSC", "Site Name", "Site ID", "2G/3G", "ID","Site Category","Priority","Technical Area","Site Layer - Qism","Type Of Sharing","Host/Guest","Alarm Occurance Time","Fault Occurance Time","Fault Clearance Time","MTTR","Hybrid Down Time","SLA Status","Site Type", "Reason Category","Reason Sub-Category","Comment", "Owner","Access Type","Cascaded To", "Final", "Office","Corp","Generator","Vendor","Reg", "Most Aff"]



desired_header_order_mt= ["Site", "TECH", "ID", "Controller", "RBSType", "Region", "nm_tier","EventTime","CeaseTime","MTTR","Duration","Reason Category","Reason Sub-Category","RootCause","DateOfOutage","Vendor","FilledBy","MR_CP","Office","Site Type"]


original_headers= {"Reason Category":["BSS", "High_temp", "Others", "Power", "TX",""],

                       "Reason Sub-Category":['BSS_HW','BSS_SW','High_Temp','High_Temp_Dependency','Others_Illegal_Intervention','Others_ROT','Others_Dependency_Illegal Intervention','Others_Unknown Reason','Others_Dependency_Unknown Reason','Others_Wrong_Action','Power_Commercial','Power_Dependency_Commercial','Power_Generator','Power_Dependency_Generator','Power_HW (Cct Breakers, Cables)','Power_Dependency_HW (Cct Breakers, Cables)','Power_Power Criteria','Power_Dependency_Power Criteria','Power_Solar Cell','Power_Dependency_Solar Cell','TX_Bad Performance','TX_Dependency_Bad Performance','TX_HW Failure','TX_Dependency_HW Failure','TX_LOS','TX_Dependency_LOS','TX_Physical Connection','TX_Dependency_Physical Connection','TX_Power Supply','TX_Dependency_Power Supply','TX_SW','TX_Telecom Egypt','TX_Dependency_Telecom Egypt','BSS/License',""],

                       "Owner":["BSS","FM","GD","ROT","RT","TD","TX","E///","ZTE",""]
}


def merge_categories(original_categories, new_categories):
    # Initialize a dictionary to store mappings
    mappings = {}
    
    # Remove empty strings and non-string objects from input lists
    original_categories = [x for x in original_categories if isinstance(x, str) and x]
    new_categories = [x for x in new_categories if isinstance(x, str) and x]

    # Iterate through each new category
    for new_cat in new_categories:
        best_similarity = 0
        best_orig_cat = None
        
        # Iterate through each original category
        for orig_cat in original_categories:
            # Calculate the similarity score between the two categories
            similarity_score = fuzz.ratio(new_cat.lower(), orig_cat.lower())

            # If the similarity score is above a threshold (e.g., 80) and higher than the current best,
            # consider them a match
            if similarity_score >= 70 and similarity_score > best_similarity:
                best_similarity = similarity_score
                best_orig_cat = orig_cat
        
        # If a match is found, add it to the mapping
        if best_orig_cat:
            mappings[new_cat] = best_orig_cat
    mappings={key: value for key,value in mappings.items() if key!=value and key!=""}
    return mappings


def apply_cascaded_to_rule(row):
    comment = row["Comment"]
    if isinstance(comment, str) and "cas" in comment.lower():
        cas_matches = re.findall(r'cas (\d{1,4})', comment, re.IGNORECASE)  # Find numeric digits with 1 to 4 characters

        if cas_matches and row["Reason Category"] != "Others":
            for match in cas_matches:
                cascaded_to_digits = match.zfill(4)  # Add leading zeros to ensure a total of 4 digits
                row["Cascaded To"] = row["Cascaded To"].replace(match, cascaded_to_digits)

                # Add a print statement here to describe the modification
                print(f"Modified Cascaded To in row {row.name}: '{row['Cascaded To']}'")

    return row



def generator(row):
    row["Generator"] = "=IF(OR(V{0}=\"Power_Generator\",V{0}=\"Power_Dependency_Generator\"), (IF(ISNUMBER(SEARCH(\"Warr\",W{0})),\"Warranty\",IF(ISNUMBER(SEARCH(\"over\",W{0})),\"Overhauling\",IF(ISNUMBER(SEARCH(\"rent\",W{0})),\"Rented\",IF(ISNUMBER(SEARCH(\"sp\",W{0})),\"Spare Part\",IF(ISNUMBER(SEARCH(\"Fuel\",W{0})),\"Fuel\",IF(ISNUMBER(SEARCH(\"shar\",W{0})),\"Sharing\",IF(ISNUMBER(SEARCH(\"main\",W{0})),\"Maintenance\",IF(AA{0}=\"Planned\",\"Planned\",\"Maintenance\"))))))))),IF(TRUE, \"\"))".format(row.name)
    return row

def final(row):
    row["Final"] = "=IF(AB{0}=\"Arish\",\"Arish\",IF(LEFT(S{0},7)=\"planned\",\"Planned\",IF(U{0}=\"TX\",\"BSS/TX\",IF(U{0}=\"BSS\",\"BSS/TX\",IF(U{0}=\"Power\",\"Power\",IF(U{0}=\"High_Temp\",\"High_Temp\",IF(V{0}=\"Others_ROT\",\"Under ROT\",IF(AND(U{0}=\"Others\",ISNUMBER(SEARCH(\"acc\",W{0}))),\"Access\",IF(AND(U{0}=\"Others\",OR(ISNUMBER(SEARCH(\"Stolen\",W{0})),ISNUMBER(SEARCH(\"Damage\",W{0})),ISNUMBER(SEARCH(\"Burn\",W{0})))),\"Damaged/Stolen\",\"Others\")))))))))".format(row.name)
    return row

def corp(row):
    row["Corp"] = "=VLOOKUP(E{0},'D:\Work\[Corpp.xlsx]Sheet1'!$B:$E,4,0)".format(row.name)
    return row

def reg(row):
    row["Reg"] = "=LEFT(E{0},3)".format(row.name)
    return row


def apply_custom_rules(row, custom_rules):
    comment = row["Comment"]
    if isinstance(comment, str):
        for keyword, rule in custom_rules.items():
            # Compile the regular expression pattern from the keyword
            pattern = re.compile(keyword, re.IGNORECASE)  # Case-insensitive matching
            if pattern.search(comment):
                if rule["Reason Category"] != "":
                    row["Reason Category"] = rule["Reason Category"]

                if rule["Reason Sub-Category"] != "":
                    row["Reason Sub-Category"] = rule["Reason Sub-Category"]

                # Add a print statement here to describe the modification
                print(f"Modified Reason Category in row {row.name}: '{row['Reason Category']}'")
                print(f"Modified Reason Sub-Category in row {row.name}: '{row['Reason Sub-Category']}'")
                break  # Once a match is found, we apply the rule and break out of the loop
    return row

def apply_tcr_logic(row):
    comment = row["Comment"]
    if isinstance(comment, str):
        tcr_match = re.search(r'tcr\s*\d{6,7}', comment, re.IGNORECASE)

        if pd.notna(row["SLA Status"]):  # Check if "SLA Status" cell is not empty
            if tcr_match:
                sla_status = row["SLA Status"]
                if isinstance(sla_status, str):
                    sla_status_words = sla_status.split()
                    if sla_status_words and sla_status_words[0].lower() != "planned":
                        row["SLA Status"] = "Planned " + " ".join(sla_status_words[1:])
                        # Add a print statement here to describe the modification
#                        print(f"Modified SLA Status in row {row.name}: '{row['SLA Status']}'")
            else:
                sla_status = row["SLA Status"]
                if isinstance(sla_status, str):
                    sla_status_words = sla_status.split()
                    if sla_status_words and sla_status_words[0].lower() != "unplanned":
                        row["SLA Status"] = "Unplanned " + " ".join(sla_status_words[1:])
                        # Add a print statement here to describe the modification
#                        print(f"Modified SLA Status in row {row.name}: '{row['SLA Status']}'")

    return row

def remove_dependency_from_subcategory(row):
    comment = row["Comment"]
    sub_category = row["Reason Sub-Category"]

    if isinstance(comment, str):
        if not re.search(r'cas', comment, re.IGNORECASE):
            # Remove "Dependency" from the sub-category using regex
            row["Reason Sub-Category"] = re.sub(r'_?Dependency$', '', sub_category, flags=re.IGNORECASE)
    
        elif re.search(r'cas', comment, re.IGNORECASE) and not re.search(r'_?Dependency', sub_category, re.IGNORECASE):
            # Add "Dependency" to the sub-category using regex
            row["Reason Sub-Category"] = f"{sub_category}_Dependency"
    
    return row




def fixes(data, custom_rules):
    data = data.apply(apply_cascaded_to_rule, axis=1)
    data = data.apply(lambda row: apply_custom_rules(row, custom_rules), axis=1)
    data = data.apply(apply_tcr_logic, axis=1)
    data = data.apply(remove_dependency_from_subcategory, axis=1)
    return data

def process_excel_files(input_files,input_files2 ,output_file):
    combined_data = pd.DataFrame(columns=desired_header_order)  
    for input_file in input_files:
        data = pd.read_excel(input_file)
        for header in desired_header_order:
            if header not in data.columns:
                data[header]=None

        data["Site ID"] = data["SiteCode"]
        data["2G/3G"] = data["Tech"]
        data["Site Layer - Qism"] = data["Site Layer Qism"]
        data["Hybrid Down Time"] = data["Down Time"]
         

        data = data[desired_header_order]


        combined_data = pd.concat([combined_data, data])








    combined_data_mt = pd.DataFrame(columns=desired_header_order_mt)  # Initialize with desired order
    for input_file2 in input_files2:
        data2 = pd.read_excel(input_file2)
        for header in desired_header_order_mt:
            if header not in data.columns:
                data[header]=None

        data2["Site Type"] = data2["RBSType"] + " " + data2["ID/OD"]
        data2["ID"] = data2["Site"].str[-4:]
        data2["TECH"] = data2["Site"].apply(lambda x: "4G" if x[0] == "L" else "3G" if x[0] == "U" else "2G")
        data2["Site"] = data2["Site"].str[-7:]
        data2["Reason Category"] = data2["Category"]
        data2["Reason Sub-Category"] = data2["SubCategory"]

        for header in desired_header_order:
            if header not in data2.columns:
                data2[header]=None
        
         

        data2["Date"] = (datetime.now()- timedelta(days=1))
        data2["BSC"]=data2["Controller"]
        data2["2G/3G"]=data2["TECH"]

        data2["Priority"]=data2["nm_tier"]
        data2["Site ID"]=data2["Site"]
        data2["Site Name"]=data2["Site"]

        data2["Technical Area"]=data2["Region"]
        data2["Site Layer - Qism"]=data2["Region"]

        data2["Fault Clearance Time"]=data2["CeaseTime"]
        data2["Alarm Occurance Time"]=data2["EventTime"]
        data2["Fault Occurance Time"]=data2["EventTime"]
        data2["Hybrid Down Time"]=data2["Duration"]
        data2["Comment"]=data2["RootCause"]

        data2 = data2[desired_header_order]

        combined_data_mt = pd.concat([combined_data_mt, data2])



    print(f"{combined_data.shape}{combined_data_mt.shape}")
    combined_data = pd.concat([combined_data, combined_data_mt])
    combined_data["Date"]=combined_data["Date"].apply(lambda x: x.strftime("%m-%d-%Y"))
    combined_data=combined_data[desired_header_order]

    for key,header in original_headers.items():
        mcd=merge_categories(header,combined_data[key].unique().tolist())
        print(combined_data[key].unique().tolist())
        print(f"\n{key}") 
        for og,nw in mcd.items():
            print(f"{og}:{nw}")
            combined_data[key] = combined_data[key].str.replace(og,nw)

    combined_data=fixes(combined_data,custom_rules)


    for key,header in original_headers.items():
        mcd=merge_categories(header,combined_data[key].unique().tolist())
        print(combined_data[key].unique().tolist())
        print(f"\n{key}") 
        for og,nw in mcd.items():
            print(f"{og}:{nw}")
            combined_data[key] = combined_data[key].str.replace(og,nw)

    combined_data.apply(generator,axis=1)
    combined_data.apply(final,axis=1)
    combined_data.apply(reg,axis=1)
    combined_data.apply(corp,axis=1)

    combined_data.to_excel(output_file, index=False)
def rename_files(input_files):
    for input_file in input_files:
        if not os.path.exists(input_file):
            continue
        
        try:
            data = pd.read_excel(input_file)
            region = data["Region"].iloc[0]
            
            # Check if region is Menoufia or Tanta (case-insensitive)
            if region.lower() in ["menoufia", "tanta"]:
                # Rename the file as "Menoufia Tanta Outage Summary Report" + date
                current_date = datetime.now().strftime("%m-%d-%Y")
                new_file_name = f"Menoufia Tanta Outage Summary Report {current_date}.xlsx"
                
                # Rename the file
                os.rename(input_file, new_file_name)
                print(f"Renamed '{input_file}' to '{new_file_name}'")
            else:
                # Apply original renaming rules for 4G, 2G, 3G, plus region and date
                region = region.title()  # Capitalize the region name
                current_date = datetime.now().strftime("%m-%d-%Y")
                new_file_name = f"{region} Outage Summary Report {current_date}.xlsx"
                
                # Rename the file
                os.rename(input_file, new_file_name)
                print(f"Renamed '{input_file}' to '{new_file_name}'")
        
        except Exception as e:
            print(f"Error renaming '{input_file}': {str(e)}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Process multiple Excel files.")
    parser.add_argument("-i", "--input1", nargs="+", help="List of input Excel files")
    parser.add_argument("-m", "--input2", nargs="+", help="List of input Excel files")
    parser.add_argument("-o", "--output", help="Output Excel file")
    args = parser.parse_args()


    if not args.input1 and not args.input2:
        rename_files(args.input1 + args.input2)

        files = os.listdir()
        input1 = [file for file in files if file.lower().startswith(("4g", "3g", "2g"))]
        input2 = [file for file in files if not file.lower().startswith(("4g", "3g", "2g"))]

        process_excel_files(input1, input2, args.output)
    else:
        process_excel_files(args.input1, args.input2, args.output)
        rename_files(args.input1 + args.input2)


